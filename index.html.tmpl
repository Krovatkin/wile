<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Browser</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.4.19/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- GLightbox CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox/dist/css/glightbox.min.css">
    <link href="https://releases.transloadit.com/uppy/v3.18.0/uppy.min.css" rel="stylesheet">
</head>
<body class="bg-gray-100 min-h-screen p-4">
    <div class="w-full max-w-none mx-4 md:w-3/4 md:max-w-4xl md:mx-auto">
        <!-- Tab Bar -->
        <div class="flex items-center gap-2 mb-4">
            <div id="tabsContainer" class="flex gap-1 flex-wrap"></div>
            <button id="addTabBtn" class="btn btn-sm rounded-md bg-blue-400 hover:bg-blue-500 text-white border-blue-400">+</button>
        </div>

        <!-- File Operations Bar -->
        <div class="flex items-center gap-2 mb-4 p-2 bg-white rounded-lg shadow-sm">
            <button id="backButton" class="btn btn-sm btn-ghost hidden" onclick="navigateBack()">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                </svg>
                Back
            </button>
            <div id="backDivider" class="divider divider-horizontal hidden"></div>
            <button id="copyBtn" class="btn btn-sm btn-ghost disabled:opacity-50" disabled onclick="copyFiles()">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                </svg>
                Copy
            </button>
            <button id="cutBtn" class="btn btn-sm btn-ghost disabled:opacity-50" disabled onclick="cutSelectedFiles()">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6-4h8a2 2 0 012 2v8a2 2 0 01-2 2H8a2 2 0 01-2-2V8a2 2 0 012-2z"></path>
                </svg>
                Cut
            </button>
            <button id="pasteBtn" class="btn btn-sm btn-ghost disabled:opacity-50" disabled onclick="pasteFiles()">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
                </svg>
                Paste
            </button>
            <div class="divider divider-horizontal"></div>
            <button id="newFolderBtn" class="btn btn-sm btn-ghost" onclick="createNewFolder()">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z"></path>
                </svg>
                New Folder
            </button>
            <div class="divider divider-horizontal"></div>
            <span id="selectionCount" class="text-sm text-gray-500">No items selected</span>
        </div>

        <!-- File Browser Container -->
        <div class="bg-blue-100 rounded-lg flex flex-col" style="height: calc(100vh - 200px);">
            <div class="p-4 text-xl font-medium">
                üìÅ <span id="currentPath">/</span>
            </div>
            <div class="px-4 pb-4 flex flex-col flex-1 overflow-hidden">
                <!-- File List Table -->
                <div class="flex-1 overflow-y-auto bg-base-100 rounded-box border border-gray-200">
                    <table class="table table-pin-rows table-md w-full">
                        <thead>
                            <tr>
                                <th class="bg-base-200 cursor-pointer hover:bg-base-300 transition-colors" onclick="sortBy('name')">
                                    <div class="flex items-center gap-1 text-gray-700">
                                        Name
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                                        </svg>
                                    </div>
                                </th>
                                <th class="bg-base-200 cursor-pointer hover:bg-base-300 transition-colors w-52" onclick="sortBy('modified')">
                                    <div class="flex items-center gap-1 text-gray-700">
                                        Modified
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                                        </svg>
                                    </div>
                                </th>
                                <th class="bg-base-200 cursor-pointer hover:bg-base-300 transition-colors w-24" onclick="sortBy('size')">
                                    <div class="flex items-center gap-1 text-gray-700">
                                        Size
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                                        </svg>
                                    </div>
                                </th>
                                <th class="bg-base-200 w-24"><!-- Actions --></th>
                            </tr>
                        </thead>
                        <tbody id="fileList">
                            <!-- Content will be populated by WebSocket -->
                        </tbody>
                    </table>
                </div>

                <!-- Upload Dropzone -->
                <div id="uploadDropzone" class="mt-2 border-2 border-dashed border-gray-300 rounded-lg bg-gray-50 flex items-center justify-center text-gray-500 text-sm" style="min-height: 48px; max-height: 48px;">
                    Drop files here to upload
                </div>

                <div id="uploadProgress" class="mt-2"></div>
                <!-- Loading Spinner -->
                <div id="loadingSpinner" class="flex justify-center items-center p-4 hidden">
                    <span class="loading loading-spinner loading-md text-blue-600"></span>
                    <span class="ml-2 text-sm text-gray-600">Loading files...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- GLightbox JS (no dependencies!) -->
    <script src="https://cdn.jsdelivr.net/gh/mcstudios/glightbox/dist/js/glightbox.min.js"></script>
    <script src="https://releases.transloadit.com/uppy/v3.18.0/uppy.min.js"></script>
    <script>
        // SVG Icon Constants
        const ICONS = {
            back: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>',
            copy: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>',
            cut: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6-4h8a2 2 0 012 2v8a2 2 0 01-2 2H8a2 2 0 01-2-2V8a2 2 0 012-2z"></path></svg>',
            paste: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg>',
            delete: '<svg class="w-4 h-4 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H8a1 1 0 00-1 1v3M4 7h16"></path></svg>',
            download: '<svg class="w-4 h-4 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>',
            rename: '<svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>',
            image: '<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"></path></svg>',
            document: '<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"></path><path d="M8 8a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1zm0 4a1 1 0 011-1h6a1 1 0 110 2H9a1 1 0 01-1-1z"></path></svg>',
            file: '<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd"></path></svg>',
            folder: '<svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"></path></svg>',
            notification: '<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>'
        };

        // URL parameter handling functions
        function getPathFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const pathParam = urlParams.get('path');
            return pathParam ? decodeURIComponent(pathParam) : '';
        }

        function updateURLPath(path) {
            const url = new URL(window.location);
            if (path === '') {
                url.searchParams.delete('path');
            } else {
                url.searchParams.set('path', encodeURIComponent(path));
            }
            
            // Update URL without reloading the page
            window.history.pushState({ path: path }, '', url);
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            if (event.state && event.state.path !== undefined) {
                // Navigate to the path from history state
                navigateToFolder(event.state.path);
            } else {
                // Fallback to reading from URL
                const pathFromURL = getPathFromURL();
                navigateToFolder(pathFromURL);
            }
        });

        // Tab state management
        let tabCounter = 0;
        let activeTabId = null;
        let tabStates = new Map();

        // Global selected files set
        let selected = new Set();

        // File operation sets
        let copiedFiles = new Set();
        let cutFiles = new Set();

        // Tab state structure
        class TabState {
            constructor() {
                this.currentPath = '';
                this.ws = null;
                this.hasFolders = false;
                this.hasFiles = false;
                this.dividerAdded = false;
                this.sortBy = 'name';  // Default sort column
                this.sortDir = 'asc';   // Default sort direction
                //this.selected = new Set();
            }
        }

        // Helper to set button state
        function setButtonState(button, enabled) {
            button.disabled = !enabled;
            button.classList.toggle('disabled:opacity-50', !enabled);
        }

        // Update button states based on selection and clipboard
        function updateButtonStates() {
            const copyBtn = document.getElementById('copyBtn');
            const cutBtn = document.getElementById('cutBtn');
            const pasteBtn = document.getElementById('pasteBtn');
            const selectionCount = document.getElementById('selectionCount');

            // Update selection count display
            const count = selected.size;
            if (count === 0) {
                selectionCount.textContent = 'No items selected';
            } else {
                selectionCount.textContent = `${count} item${count > 1 ? 's' : ''} selected`;
            }

            // Enable/disable buttons based on state
            const hasSelection = selected.size > 0;
            setButtonState(copyBtn, hasSelection);
            setButtonState(cutBtn, hasSelection);
            setButtonState(pasteBtn, copiedFiles.size > 0 || cutFiles.size > 0);
        }

        // Helper function for clipboard operations (copy/cut)
        function performClipboardOperation(toClearSet, toFillSet, operation, notificationType) {
            if (selected.size === 0) return;

            const count = selected.size;

            toClearSet.clear();
            toFillSet.clear();
            selected.forEach(item => toFillSet.add(item));

            console.log(`${operation} files:`, Array.from(toFillSet));

            clearSelection();
            updateButtonStates();

            showNotification(`${count} item${count > 1 ? 's' : ''} ${operation}`, notificationType);
        }

        // Copy files operation
        function copyFiles() {
            performClipboardOperation(cutFiles, copiedFiles, 'copied', 'success');
        }

        // Cut files operation
        function cutSelectedFiles() {
            performClipboardOperation(copiedFiles, cutFiles, 'cut', 'warning');
        }

        // Helper function to create file/folder item with delete button
        function createItemHTML(entryObj, attributes, icon) {
            const { name, path, isDir, size, modified, sizeStale } = entryObj;

            // Format size to human-readable format
            const formatSize = (bytes) => {
                if (bytes < 0) return '-';
                if (bytes < 1024) return bytes + '  B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
                if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
                if (bytes < 1024 * 1024 * 1024 * 1024) return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
                return (bytes / (1024 * 1024 * 1024 * 1024)).toFixed(2) + ' TB';
            };

            const formattedSize = formatSize(size);
            
            // Format date
            const formatDate = (timestamp) => {
                if (!timestamp) return '-';
                const date = new Date(timestamp * 1000);
                return date.toLocaleString();
            };
            const formattedDate = formatDate(modified);

            // Add warning emoji if size data is stale
            const sizeDisplay = sizeStale ? `‚ö†Ô∏è ${formattedSize}` : formattedSize;

            // Download button
            const downloadButton = isDir ? `
                <button onclick="downloadFolder('${path.replace(/'/g, "\\'")}', event)"
                        class="p-1 hover:bg-blue-100 rounded"
                        title="Download folder as ZIP">
                    ${ICONS.download}
                </button>
            ` : `
                <a href="/?path=${encodeURIComponent(path)}" 
                   download="${name}"
                   onclick="event.stopPropagation()"
                   class="p-1 hover:bg-blue-100 rounded flex items-center justify-center text-blue-600"
                   title="Download file">
                    ${ICONS.download}
                </a>
            `;

            const renameButton = `
                <button onclick="renameItem('${path.replace(/'/g, "\\'")}', '${name.replace(/'/g, "\\'")}', event)"
                        class="p-1 hover:bg-gray-100 rounded"
                        title="Rename ${isDir ? 'folder' : 'file'}">
                    ${ICONS.rename}
                </button>
            `;

            const deleteButton = `
                <button onclick="deleteItem('${path.replace(/'/g, "\\'")}', event)"
                        class="delete-btn p-1 hover:bg-red-100 rounded"
                        title="Delete ${isDir ? 'folder' : 'file'}">
                    ${ICONS.delete}
                </button>
            `;

            // Merge default classes with any classes passed in attributes
            // This prevents duplicate class attributes which browsers ignore
            const defaultClasses = "hover group cursor-pointer border-b border-base-200";
            let finalAttributes = attributes || '';
            if (finalAttributes.includes('class="')) {
                finalAttributes = finalAttributes.replace('class="', `class="${defaultClasses} `);
            } else {
                finalAttributes += ` class="${defaultClasses}"`;
            }

            return `
                <tr ${finalAttributes} title="${name}">
                    <td>
                        <div class="flex items-center gap-2 min-w-0">
                            <span class="flex-shrink-0">${icon}</span>
                            <span class="truncate font-medium text-gray-700">${name}</span>
                        </div>
                    </td>
                    <td class="text-sm text-gray-500 whitespace-nowrap">
                        ${formattedDate}
                    </td>
                    <td class="text-sm text-gray-500 whitespace-nowrap font-mono">
                        ${sizeDisplay}
                    </td>
                    <td>
                        <div class="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                            ${downloadButton}
                            ${renameButton}
                            ${deleteButton}
                        </div>
                    </td>
                </tr>
            `;
        }



        // Paste files operation
        function pasteFiles() {
            if (copiedFiles.size === 0 && cutFiles.size === 0) return;

            const filesToPaste = copiedFiles.size > 0 ? copiedFiles : cutFiles;
            const operation = copiedFiles.size > 0 ? 'copy' : 'move';

            console.log(`Pasting ${filesToPaste.size} files with ${operation} operation:`, Array.from(filesToPaste));
            console.log('Target directory:', currentPath);

            // Prepare request parameters
            const params = new URLSearchParams();
            filesToPaste.forEach(file => {
                params.append('srcs', file);
            });
            params.append('action', operation === 'copy' ? 'copy' : 'paste');
            params.append('dest', currentPath);

            // Clear clipboard before making request
            const fileCount = filesToPaste.size;
            copiedFiles.clear();
            cutFiles.clear();
            updateButtonStates();

            // Make GET request to server with parameters in URL
            fetch(`/manage?${params.toString()}`)
            .then(response => response.json())
            .then(data => {
                if (data.status === 'ok') {
                    showNotification(`${fileCount} item${fileCount > 1 ? 's' : ''} ${operation === 'copy' ? 'copied' : 'moved'} successfully`, 'info');
                    navigateToFolder(currentPath);
                } else {
                    showNotification(data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Error pasting files:', error);
                showNotification('Failed to paste files', 'error');
            });
        }


        // Download folder as ZIP
        function downloadFolder(folderPath, event) {
            event.stopPropagation(); // Prevent navigation when clicking download

            // Encode the path for URL
            const encodedPath = encodeURIComponent(folderPath);

            // Trigger download by navigating to zip endpoint
            window.location.href = `/zip?path=${encodedPath}`;
        }

        // Rename file/folder operation
        function renameItem(itemPath, currentName, event) {
            event.stopPropagation(); // Prevent navigation when clicking rename

            const newName = prompt('Enter new name:', currentName);
            if (!newName || newName === currentName) {
                return; // User cancelled or didn't change the name
            }

            // Send rename request
            fetch('/rename', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    path: itemPath,
                    newName: newName
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showNotification(`Renamed to "${newName}"`, 'info');

                    // Update the DOM without navigating
                    // Find the list item by data-path attribute
                    const li = document.querySelector(`li[data-path="${itemPath}"]`);
                    if (li) {
                        // Update the displayed name
                        const nameSpan = li.querySelector('span.truncate');
                        if (nameSpan) {
                            nameSpan.textContent = newName;
                        }

                        // Update all onclick attributes with new path
                        const newPath = data.newPath;
                        const escapedNewPath = newPath.replace(/'/g, "\\'");
                        const escapedOldPath = itemPath.replace(/'/g, "\\'");

                        // Update data-path attribute
                        li.setAttribute('data-path', newPath);

                        // Update the main li onclick
                        const liOnclick = li.getAttribute('onclick');
                        if (liOnclick) {
                            li.setAttribute('onclick', liOnclick.replace(escapedOldPath, escapedNewPath));
                        }

                        // Update ondblclick if exists (for folders)
                        const liOndblclick = li.getAttribute('ondblclick');
                        if (liOndblclick) {
                            li.setAttribute('ondblclick', liOndblclick.replace(escapedOldPath, escapedNewPath));
                        }

                        // Update download button if exists
                        const downloadBtn = li.querySelector('button[onclick*="downloadFolder"]');
                        if (downloadBtn) {
                            const downloadOnclick = downloadBtn.getAttribute('onclick');
                            downloadBtn.setAttribute('onclick', downloadOnclick.replace(escapedOldPath, escapedNewPath));
                        }

                        // Update rename button
                        const renameBtn = li.querySelector('button[onclick*="renameItem"]');
                        if (renameBtn) {
                            renameBtn.setAttribute('onclick', `renameItem('${escapedNewPath}', '${newName.replace(/'/g, "\\'")}', event)`);
                        }

                        // Update delete button
                        const deleteBtn = li.querySelector('button[onclick*="deleteItem"]');
                        if (deleteBtn) {
                            deleteBtn.setAttribute('onclick', `deleteItem('${escapedNewPath}', event)`);
                        }

                        // Update title
                        li.setAttribute('title', newName);
                    }
                } else {
                    showNotification(data.error || 'Failed to rename', 'error');
                }
            })
            .catch(error => {
                console.error('Error renaming item:', error);
                showNotification('Failed to rename item', 'error');
            });
        }

        // Create new folder operation
        function createNewFolder() {
            const folderName = prompt('Enter folder name:');
            if (!folderName) {
                return; // User cancelled
            }

            const currentPath = getTabs()[activeTabIndex].path;
            const params = new URLSearchParams();
            params.append('action', 'new_folder');
            params.append('dest', currentPath);
            params.append('name', folderName);

            fetch('/manage?' + params.toString())
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'ok') {
                        showNotification(`Created folder "${folderName}"`, 'info');
                        // Refresh the current directory
                        loadDirectory(currentPath);
                    } else {
                        showNotification(data.error || 'Failed to create folder', 'error');
                    }
                })
                .catch(error => {
                    console.error('Error creating folder:', error);
                    showNotification('Failed to create folder', 'error');
                });
        }

        // Delete file/folder operation
        function deleteItem(itemPath, event) {
            event.stopPropagation(); // Prevent selection when clicking delete
            
            if (!confirm(`Are you sure you want to delete "${itemPath.split('/').pop()}"?`)) {
                return;
            }

            const params = new URLSearchParams();
            params.append('action', 'delete');
            params.append('srcs', itemPath);

            fetch(`/manage?${params.toString()}`)
            .then(response => response.json())
            .then(data => {
                if (data.status === 'ok') {
                    showNotification('Item deleted successfully', 'success');
                    navigateToFolder(currentPath);
                } else {
                    showNotification(data.error || 'Failed to delete item', 'error');
                }
            })
            .catch(error => {
                console.error('Error deleting item:', error);
                showNotification('Failed to delete item', 'error');
            });
        }


        // Show notification (simple implementation)
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `alert alert-${type} fixed top-4 right-4 w-auto max-w-md z-50 shadow-lg`;
            notification.innerHTML = `
                ${ICONS.notification}
                <span>${message}</span>
            `;

            document.body.appendChild(notification);

            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Save current global state to active tab
        function saveCurrentStateToTab() {
            if (activeTabId && tabStates.has(activeTabId)) {
                const state = tabStates.get(activeTabId);
                state.currentPath = currentPath;
                state.ws = ws;
                state.hasFolders = hasFolders;
                state.hasFiles = hasFiles;
                state.dividerAdded = dividerAdded;
                state.selected = new Set(selected);
                state.sortBy = currentSortBy;
                state.sortDir = currentSortDir;
            }
        }

        // Helper function to clear content and load tab state
        function clearAndLoadTabState(tabId) {
            // Clear current HTML content
            fileListElement.innerHTML = '';

            // Close WebSocket if open
            if (ws) {
                ws.close();
                ws = null;
            }

            // Clear selection when switching tabs
            clearSelection();

            // Get tab state
            const state = tabStates.get(tabId);
            if (state) {
                // Set global variables from tab state
                currentPath = state.currentPath;
                ws = state.ws;
                hasFolders = state.hasFolders;
                hasFiles = state.hasFiles;
                dividerAdded = state.dividerAdded;
                selected = new Set(); // Start with empty selection on tab switch
                currentSortBy = state.sortBy;
                currentSortDir = state.sortDir;

                // Navigate to the folder
                navigateToFolder(currentPath);
            }
        }

        function createTab() {
            const tabId = `tab-${++tabCounter}`;

            // Create new state and copy current global state
            const newState = new TabState();
            newState.currentPath = currentPath;
            newState.hasFolders = hasFolders;
            newState.hasFiles = hasFiles;
            newState.dividerAdded = dividerAdded;
            newState.selected = new Set(); // New tabs start with empty selection
            newState.sortBy = currentSortBy;
            newState.sortDir = currentSortDir;
            // Note: don't copy ws, each tab needs its own connection

            tabStates.set(tabId, newState);

            const tabElement = document.createElement('div');
            tabElement.className = 'btn btn-sm btn-outline flex items-center gap-2';
            tabElement.id = `tab-header-${tabId}`;
            tabElement.innerHTML = `
                <span onclick="switchToTab('${tabId}')" class="cursor-pointer">Tab ${tabCounter}</span>
                <button onclick="closeTab('${tabId}'); event.stopPropagation();" class="btn btn-xs btn-circle btn-ghost">√ó</button>
            `;

            document.getElementById('tabsContainer').appendChild(tabElement);
            switchToTab(tabId);
            return tabId;
        }

        function switchToTab(tabId) {
            // Save current state to the currently active tab
            saveCurrentStateToTab();

            // Deactivate all tabs
            document.querySelectorAll('#tabsContainer .btn').forEach(el => {
                el.classList.remove('btn-active');
                el.classList.add('btn-outline');
            });

            // Activate selected tab
            const tabHeader = document.getElementById(`tab-header-${tabId}`);
            if (tabHeader) {
                tabHeader.classList.add('btn-active');
                tabHeader.classList.remove('btn-outline');
                activeTabId = tabId;

                // Clear and load the new tab state
                clearAndLoadTabState(tabId);
            }
        }

        function closeTab(tabId) {
            // Don't close if it's the last tab
            if (tabStates.size <= 1) {
                return;
            }

            const tabHeader = document.getElementById(`tab-header-${tabId}`);
            if (tabHeader) {
                tabHeader.remove();
            }

            // Close WebSocket if it exists
            const state = tabStates.get(tabId);
            if (state && state.ws) {
                state.ws.close();
            }

            // Remove state
            tabStates.delete(tabId);

            // If this was the active tab, switch to another
            if (activeTabId === tabId) {
                const remainingTabs = document.querySelectorAll('#tabsContainer .btn');
                if (remainingTabs.length > 0) {
                    const firstTabId = remainingTabs[0].id.replace('tab-header-', '');
                    switchToTab(firstTabId);
                }
            }
        }

        function addNewTab() {
            createTab();
        }

        function toggleFileSelection(element) {
            const itemType = element.dataset.fileType;
            const filePath = element.dataset.path;
            const parentLi = element.closest('li'); // Get the parent <li>

            if (selected.has(filePath)) {
                // Remove from selection
                selected.delete(filePath);
                parentLi.classList.remove('!bg-blue-200', '!text-white');
            } else {
                // Add to selection
                selected.add(filePath);
                parentLi.classList.add('!bg-blue-200', '!text-white');
            }
            
            console.log('Selected files:', Array.from(selected));
            updateButtonStates(); // Update button states after selection change
        }

        // Clear selection and update UI
        function clearSelection() {
            // Clear selection classes from all li elements
            document.querySelectorAll('li.\\!bg-blue-200').forEach(li => {
                li.classList.remove('!bg-blue-200', '!text-white');
            });
            
            // Clear the selection set
            selected.clear();
            updateButtonStates();
        }

        // Original code with document support added
        let lightbox;

        // Check if file is an image
        function isImageFile(filename) {
            const imageExtensions = ['.jpg', '.jpeg', '.png'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return imageExtensions.includes(ext);
        }

        // Check if file is a document
        function isDocumentFile(filename) {
            const documentExtensions = ['.docx', '.doc', '.xls', '.xlsx', '.ppt', '.pptx', '.pdf'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return documentExtensions.includes(ext);
        }

        // Get appropriate icon for file type
        function getFileIcon(filename, type) {
            if (type === 'image' || isImageFile(filename)) {
                return ICONS.image;
            } else if (type === 'document' || isDocumentFile(filename)) {
                return ICONS.document;
            } else {
                return ICONS.file;
            }
        }


        // Reinitialize lightbox after adding new images
        function reinitializeLightbox() {
            if (lightbox) {
                lightbox.destroy();
            }
            lightbox = GLightbox({
                selector: 'none',
                // openEffect: 'none',
                // touchNavigation: true,
                // loop: true,
                // autoplayVideos: false
            });

            // Extract common navigation handler
            function createNavigationHandler(direction) {
                return function(e) {
                    e.preventDefault();
                    const currentHref = lightbox.elements[0].href;
                    const element = findImageElement(currentHref, direction);

                    if (element) {
                        lightbox.setElements([{
                            href: element.getAttribute('href'),
                            title: element.getAttribute('data-title'),
                            description: element.getAttribute('data-description')
                        }]);
                        lightbox.goToSlide(0);
                    }
                };
            }

            lightbox.on('open', function() {
                const nextBtn = document.querySelector('.gnext');
                const prevBtn = document.querySelector('.gprev');

                if (nextBtn) nextBtn.onclick = createNavigationHandler(1);
                if (prevBtn) prevBtn.onclick = createNavigationHandler(-1);
            });

        }

        function openLightbox(element) {
            lightbox.setElements([
                {
                    href: element.getAttribute('href'),
                    title: element.getAttribute('data-title'),
                    description: element.getAttribute('data-description')
                }
            ]);
            lightbox.open();
        }

        function findImageElement(currentHref, direction) {
            // Get all image links in DOM
            const imageLinks = document.querySelectorAll('li[href^="/image?path="]');
            const imageArray = Array.from(imageLinks);
            
            // Find current element index
            const currentIndex = imageArray.findIndex(el => el.getAttribute('href') === currentHref);

            
            if (currentIndex !== -1) {
                let newIndex;
                
                if (direction === 1) {
                    // Next: wrap to first if at end
                    newIndex = (currentIndex + 1) % imageArray.length;
                } else if (direction === -1) {
                    // Previous: wrap to last if at beginning
                    newIndex = currentIndex === 0 ? imageArray.length - 1 : currentIndex - 1;
                }
                
                return imageArray[newIndex];
            }
            
            return null;
        }


        // Templates
        const folderTemplate = (item) => {
            const {name, path} = item;

            return createItemHTML(item,
                `href="javascript:void(0)" ondblclick="navigateToFolder('${item.path.replace(/'/g, "\\'")}')" class="text-yellow-600 hover:bg-yellow-50" onclick="event.preventDefault(); toggleFileSelection(this);" data-file-type="folder" data-path="${path}"`,
                ICONS.folder
            );
        };

        const fileTemplate = (item) => {
            const {name, path} = item;
            const isImage = isImageFile(name);
            const isDocument = isDocumentFile(name);
            const isSelected = selected.has(path);

            let colorClass, fileType;

            if (isImage) {
                fileType = 'image';
                colorClass = isSelected ? '!bg-blue-200 !text-white' : 'text-green-600 hover:bg-green-50';
            } else if (isDocument) {
                fileType = 'document';
                colorClass = isSelected ? '!bg-blue-200 !text-white' : 'text-purple-600 hover:bg-purple-50';
            } else {
                fileType = 'file';
                colorClass = isSelected ? '!bg-blue-200 !text-white' : 'text-blue-600 hover:bg-blue-50';
            }

            const fileId = `file-${path.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const commonAttrs = `id="${fileId}" data-file-type="${fileType}" data-path="${path}"`;
            const baseClass = `file-item ${colorClass}`;

            if (isImage) {
                const imageUrl = `/image?path=${encodeURIComponent(path)}`;
                return createItemHTML(
                    item,
                    `href="${imageUrl}" ${commonAttrs} class="glightbox ${baseClass}" data-gallery="gallery" data-title="${name}" onclick="event.preventDefault(); toggleFileSelection(this);" ondblclick="event.stopPropagation(); openLightbox(this);"`,
                    getFileIcon(name, 'image')
                );
            } else if (isDocument) {
                const docViewerUrl = `/doc_viewer?path=${encodeURIComponent(path)}`;
                return createItemHTML(
                    item,
                    `href="${docViewerUrl}" ${commonAttrs} class="${baseClass}" onclick="event.preventDefault(); toggleFileSelection(this);" ondblclick="event.stopPropagation(); window.open('${docViewerUrl}', '_blank');"`,
                    getFileIcon(name, 'document')
                );
            } else {
                const fileUrl = `/file?path=${encodeURIComponent(path)}`;
                return createItemHTML(
                    item,
                    `href="${fileUrl}" ${commonAttrs} class="${baseClass}" onclick="event.preventDefault(); toggleFileSelection(this);" ondblclick="event.stopPropagation(); window.location.href='${fileUrl}';"`,
                    getFileIcon(name, 'file')
                );
            }
        };

        const dividerTemplate = () => `<div class="divider my-1"></div>`;

        // Global variables (start with defaults)
        let ws = null;
        let currentPath = '';
        let currentRequestId = 0; // Counter for request identification
        let currentSortBy = 'name'; // Default sort column
        let currentSortDir = 'asc'; // Default sort direction
        let hasFolders = false;
        let hasFiles = false;
        let dividerAdded = false;
        const rootPath = "{{.RootPath}}";

        // DOM elements
        const fileListElement = document.getElementById('fileList');
        const spinnerElement = document.getElementById('loadingSpinner');
        const currentPathElement = document.getElementById('currentPath');
        const backButtonElement = document.getElementById('backButton');
        const backDividerElement = document.getElementById('backDivider');

        // Show/hide spinner
        function showSpinner() {
            spinnerElement.classList.remove('hidden');
        }

        function hideSpinner() {
            spinnerElement.classList.add('hidden');
            // Reinitialize lightbox when loading is complete
            setTimeout(reinitializeLightbox, 100);
        }

        // Update back button visibility
        function updateBackButton() {
            if (currentPath === '') {
                backButtonElement.classList.add('hidden');
                backDividerElement.classList.add('hidden');
            } else {
                backButtonElement.classList.remove('hidden');
                backDividerElement.classList.remove('hidden');
            }
        }

        // Clear file list and reset state
        function clearFileList() {
            fileListElement.innerHTML = '';
            hasFolders = false;
            hasFiles = false;
            dividerAdded = false;
        }

        // Append HTML immediately to the file list
        function appendToFileList(html) {
            fileListElement.insertAdjacentHTML('beforeend', html);
        }

        // Add divider between folders and files if needed
        function addDividerIfNeeded() {
            if (hasFolders && hasFiles && !dividerAdded) {
                appendToFileList(dividerTemplate());
                dividerAdded = true;
            }
        }

        // Handle incoming WebSocket messages
        function handleMessage(event) {
            try {
                const msg = JSON.parse(event.data);
                console.log('Received:', msg);

                // Check if message is for current request (ignore stale messages)
                if (msg.requestId !== currentRequestId) {
                    console.log(`Ignoring message for request ${msg.requestId} (current: ${currentRequestId})`);
                    return;
                }

                const data = msg.items;

                // If empty array, hide spinner and stop
                if (Array.isArray(data) && data.length === 0) {
                    hideSpinner();
                    return;
                }

                // Show spinner when we start receiving data
                if (Array.isArray(data) && data.length > 0) {
                    showSpinner();
                }

                // Process each item in the array and append immediately
                data.forEach(item => {
                    if (item.isDir) {
                        if (!hasFolders) {
                            hasFolders = true;
                        }
                        appendToFileList(folderTemplate(item));
                    } else {
                        if (!hasFiles) {
                            hasFiles = true;
                            addDividerIfNeeded();
                        }
                        appendToFileList(fileTemplate(item));
                    }
                });

            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
            }
        }

        // Connect to WebSocket
        function connectWebSocket(path) {
            // Close existing connection if any
            if (ws) {
                ws.close();
            }

            clearFileList();
            showSpinner();

            currentPath = path;
            // Display path with leading slash for UI
            const displayPath = rootPath + (path === '' ? '' : '/' + path);
            currentPathElement.textContent = displayPath;
            updateBackButton();

            // Update URL parameter when navigating
            updateURLPath(path);

            // Use current domain and port instead of hardcoded localhost
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/files`;

            ws = new WebSocket(wsUrl);

            ws.onopen = function(event) {
                console.log('WebSocket connected');
                // Send path request
                requestPath(path);
            };

            ws.onmessage = handleMessage;

            ws.onclose = function(event) {
                console.log('WebSocket disconnected');
                hideSpinner();
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                hideSpinner();
            };
        }

        // Request a path without reconnecting
        function requestPath(path) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.error('WebSocket not connected');
                return;
            }

            clearFileList();
            showSpinner();

            // Increment request counter
            currentRequestId++;

            currentPath = path;
            // Display path with leading slash for UI
            const displayPath = rootPath + (path === '' ? '' : '/' + path);
            currentPathElement.textContent = displayPath;
            updateBackButton();

            // Update URL parameter when navigating
            updateURLPath(path);

            console.log('Requesting path:', path, 'ID:', currentRequestId, 'Sort:', currentSortBy, currentSortDir);
            ws.send(JSON.stringify({
                path: path,
                requestId: currentRequestId,
                sortBy: currentSortBy,
                dir: currentSortDir
            }));
        }

        // Navigate to folder - use the path from server response directly
        function navigateToFolder(folderPath) {
            clearSelection(); // Clear selection when navigating

            // If WebSocket is open, just request the new path
            if (ws && ws.readyState === WebSocket.OPEN) {
                requestPath(folderPath);
            } else {
                // Otherwise reconnect
                connectWebSocket(folderPath);
            }
        }

        // Navigate back to parent directory
        function navigateBack() {
            if (currentPath === '') return; // Already at root

            clearSelection(); // Clear selection when navigating back

            // Get parent path by removing the last segment
            const pathParts = currentPath.split('/');
            pathParts.pop(); // Remove last part
            const parentPath = pathParts.join('/');

            navigateToFolder(parentPath);
        }

        // Sort files by column
        function sortBy(column) {
            console.log('Sort by:', column);

            // If clicking same column, toggle direction
            if (currentSortBy === column) {
                currentSortDir = currentSortDir === 'asc' ? 'desc' : 'asc';
            } else {
                // New column, default to ascending
                currentSortBy = column;
                currentSortDir = 'asc';
            }

            console.log('New sort:', currentSortBy, currentSortDir);

            // Request current path with new sort settings
            if (ws && ws.readyState === WebSocket.OPEN) {
                requestPath(currentPath);
            } else {
                connectWebSocket(currentPath);
            }
        }

        let uppy = null;

        function initializeUpload() {
            //if (!writeMode) return;

            uppy = new Uppy.Uppy()
            .use(Uppy.Tus, {
                endpoint: '/upload/tus/',
                resume: true,
                chunkSize: 1024 * 1024,
            })
            // .use(Uppy.Dashboard, {
            //     target: '#fileList',
            //     inline: true,
            //     height: 150,
            //     hideUploadButton: true,
            //     proudlyDisplayPoweredByUppy: false,
            //     note: `Drop files here to upload to: /${currentPath || 'root'}`,
            // })
            .use(Uppy.StatusBar, {
                target: '#uploadProgress',
                hideUploadButton: true,
            });

            uppy.on('file-added', (file) => {
                uppy.setFileMeta(file.id, {
                    relativePath: currentPath,
                    filename: file.name,
                });
                uppy.upload();
            });

            uppy.on('complete', (result) => {
                if (result.successful.length > 0) {
                    setTimeout(() => navigateToFolder(currentPath), 1000);
                }
            });

            const dropzone = document.getElementById('uploadDropzone');
            dropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropzone.classList.add('border-blue-400', 'bg-blue-50');
            });
            dropzone.addEventListener('dragleave', (e) => {
                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
            });
            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
                Array.from(e.dataTransfer.files).forEach(file => {
                    uppy.addFile({ name: file.name, type: file.type, data: file });
                });
            });
        }


        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            const writeMode = {{.WriteMode}};  // Changed to writeMode

            if (writeMode) {
                initializeUpload();
            } else {
                // Hide dropzone in read-only mode
                const dropzone = document.getElementById('uploadDropzone');
                if (dropzone) dropzone.style.display = 'none';
            }
            
            
            // Initialize lightbox
            reinitializeLightbox();

            // Add event listener for new tab button
            document.getElementById('addTabBtn').addEventListener('click', addNewTab);

            // Initialize button states
            updateButtonStates();

            // Disable buttons if NOT in write mode (read-only by default)
            if (!writeMode) {
                ['copyBtn', 'cutBtn', 'pasteBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    btn.disabled = true;
                    btn.classList.add('opacity-50', 'cursor-not-allowed');
                    btn.title = 'Read-only mode - use --write flag to enable file operations';
                });
            }

            // Get initial path from URL parameter
            currentPath = getPathFromURL();

            // Create first tab (will use path from URL or default to root)
            createTab();
        });
    </script>
</body>
</html>


